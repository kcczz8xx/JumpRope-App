# 表單元件 - 主表單 (NewCourseForm)

## 檔案位置

`@/components/feature/school-service/course/NewCourseForm.tsx`

## 元件職責

`NewCourseForm` 是整個多步驟表單的核心控制器，負責：

- 管理表單狀態
- 控制步驟切換
- 處理資料驗證
- 提交表單資料
- 協調子元件

## 元件結構

```typescript
interface NewCourseFormProps {
  schools: School[]; // 學校列表
  isLoadingSchools?: boolean; // 載入狀態
  quotationId?: string; // 報價單 ID（可選）
}

export default function NewCourseForm({
  schools,
  isLoadingSchools = false,
  quotationId,
}: NewCourseFormProps) {
  // 狀態管理
  // 驗證邏輯
  // 提交處理
  // 渲染邏輯
}
```

## 狀態管理

### 1. 表單資料狀態

```typescript
const [formData, setFormData] = useState<NewCourseFormData>(
  getDefaultNewCourseFormData()
);
```

**初始值：**

```typescript
{
  school: {
    schoolId: undefined,
    schoolName: "",
    schoolNameEn: "",
    address: "",
    // ...
  },
  contact: {
    nameChinese: "",
    nameEnglish: "",
    // ...
  },
  academicYear: "2026-2027", // 自動計算
  courses: [
    {
      id: "uuid-xxx",
      courseName: "",
      courseType: "",
      // ...
    }
  ]
}
```

### 2. 步驟控制狀態

```typescript
const [currentStep, setCurrentStep] = useState(0);

const STEPS = [{ label: "學校資料" }, { label: "課程資料" }, { label: "總結" }];
```

### 3. 錯誤狀態

```typescript
const [errors, setErrors] = useState<Record<string, string>>({});
```

**錯誤格式：**

```typescript
{
  "schoolName": "請輸入學校名稱",
  "course_0_courseName": "請輸入課程名稱",
  "course_0_studentPerLessonFee": "請輸入有效的收費金額"
}
```

### 4. 提交狀態

```typescript
const [isSubmitting, setIsSubmitting] = useState(false);
```

## 資料更新處理

### 1. 學校資料更新

```typescript
const handleSchoolChange = useCallback((updates: Partial<SchoolBasicData>) => {
  setFormData((prev) => {
    const updatedSchool = { ...prev.school, ...updates };

    // 即時清除錯誤
    setErrors((prevErrors) => {
      const newErrors = { ...prevErrors };
      Object.keys(updates).forEach((key) => {
        delete newErrors[key];
      });

      // 日期範圍驗證
      if (
        updatedSchool.partnershipEndDate &&
        updatedSchool.partnershipStartDate &&
        updatedSchool.partnershipEndDate < updatedSchool.partnershipStartDate
      ) {
        newErrors.partnershipEndDate = "結束日期不能早於開始日期";
      }

      return newErrors;
    });

    return {
      ...prev,
      school: updatedSchool,
    };
  });
}, []);
```

**設計要點：**

- 使用 `useCallback` 避免不必要的重新渲染
- 即時清除已修正欄位的錯誤
- 即時驗證日期範圍

### 2. 聯絡人資料更新

```typescript
const handleContactChange = useCallback(
  (updates: Partial<SchoolContactData>) => {
    setFormData((prev) => ({
      ...prev,
      contact: { ...prev.contact, ...updates },
    }));

    // 清除錯誤
    setErrors((prev) => {
      const newErrors = { ...prev };
      Object.keys(updates).forEach((key) => {
        delete newErrors[
          `contact${key.charAt(0).toUpperCase() + key.slice(1)}`
        ];
      });
      return newErrors;
    });
  },
  []
);
```

### 3. 課程資料更新

```typescript
const handleCoursesChange = useCallback((courses: CourseItemData[]) => {
  setFormData((prev) => ({ ...prev, courses }));
}, []);
```

**注意：** 課程資料的細部更新由 `CoursesFormStep` 元件處理。

## 驗證邏輯

### 1. 步驟 1 驗證（學校資料）

```typescript
const validateStep1 = useCallback((): boolean => {
  const newErrors: Record<string, string> = {};
  const { school, contact } = formData;

  // 學校資料驗證
  if (!school.schoolName.trim()) {
    newErrors.schoolName = "請輸入學校名稱";
  }
  if (!school.address.trim()) {
    newErrors.address = "請輸入學校地址";
  }
  if (!school.partnershipStartDate) {
    newErrors.partnershipStartDate = "請選擇合作開始日期";
  }
  if (
    school.partnershipEndDate &&
    school.partnershipStartDate &&
    school.partnershipEndDate < school.partnershipStartDate
  ) {
    newErrors.partnershipEndDate = "結束日期不能早於開始日期";
  }
  if (!school.confirmationChannel.trim()) {
    newErrors.confirmationChannel = "請輸入確認渠道";
  }

  // 聯絡人資料驗證
  if (!contact.nameChinese.trim()) {
    newErrors.contactNameChinese = "請輸入聯絡人姓名";
  }

  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
}, [formData]);
```

**驗證規則：**

- 必填欄位：學校名稱、地址、合作開始日期、確認渠道、聯絡人姓名
- 日期範圍：結束日期不能早於開始日期
- 字串清理：使用 `trim()` 避免空白字串

### 2. 步驟 2 驗證（課程資料）

```typescript
const validateStep2 = useCallback((): boolean => {
  const newErrors: Record<string, string> = {};
  const { courses } = formData;

  // 檢查是否有課程
  if (courses.length === 0) {
    newErrors.courses = "請至少新增一個課程";
    setErrors(newErrors);
    return false;
  }

  // 逐一驗證每個課程
  courses.forEach((course, index) => {
    const prefix = `course_${index}_`;

    // 基本資料驗證
    if (!course.courseName.trim()) {
      newErrors[`${prefix}courseName`] = "請輸入課程名稱";
    }
    if (!course.courseType || !course.courseType.trim()) {
      newErrors[`${prefix}courseType`] = "請選擇課程類型";
    }
    if (!course.chargingModel || course.chargingModel.length === 0) {
      newErrors[`${prefix}chargingModel`] = "請選擇至少一個收費模式";
    }

    // 日期範圍驗證
    if (
      course.endDate &&
      course.startDate &&
      course.endDate < course.startDate
    ) {
      newErrors[`${prefix}endDate`] = "結束日期不能早於開始日期";
    }

    // 導師數量驗證
    if (!course.requiredTutors || course.requiredTutors < 1) {
      newErrors[`${prefix}requiredTutors`] = "至少需要 1 位導師";
    }

    // 收費金額驗證（依 chargingModel 而定）
    course.chargingModel.forEach((model) => {
      switch (model) {
        case ChargingModel.STUDENT_PER_LESSON:
          if (!course.studentPerLessonFee || course.studentPerLessonFee <= 0) {
            newErrors[`${prefix}studentPerLessonFee`] = "請輸入有效的收費金額";
          }
          break;
        case ChargingModel.TUTOR_PER_LESSON:
          if (!course.tutorPerLessonFee || course.tutorPerLessonFee <= 0) {
            newErrors[`${prefix}tutorPerLessonFee`] = "請輸入有效的收費金額";
          }
          break;
        // ... 其他收費模式
      }
    });
  });

  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
}, [formData]);
```

**驗證規則：**

- 至少要有一個課程
- 每個課程的必填欄位：課程名稱、課程類型、收費模式
- 根據選擇的收費模式驗證對應的收費金額
- 日期範圍驗證
- 導師數量至少為 1

## 步驟控制

### 1. 下一步

```typescript
const handleNext = useCallback(() => {
  let isValid = false;

  if (currentStep === 0) {
    isValid = validateStep1();
  } else if (currentStep === 1) {
    isValid = validateStep2();
  }

  if (isValid) {
    setCurrentStep((prev) => Math.min(prev + 1, STEPS.length - 1));
  }
}, [currentStep, validateStep1, validateStep2]);
```

**流程：**

1. 根據當前步驟執行對應的驗證
2. 驗證通過後才允許進入下一步
3. 使用 `Math.min` 防止超出步驟範圍

### 2. 上一步

```typescript
const handlePrev = useCallback(() => {
  setCurrentStep((prev) => Math.max(prev - 1, 0));
}, []);
```

**流程：**

- 直接返回上一步，不需要驗證
- 使用 `Math.max` 防止小於 0

### 3. 步驟點擊

```typescript
const handleStepClick = useCallback((step: number) => {
  setCurrentStep(step);
}, []);
```

**注意：** 允許直接點擊步驟指示器跳轉，不進行驗證。

## 表單提交

```typescript
const handleSubmit = useCallback(async () => {
  setIsSubmitting(true);

  try {
    const { school, contact, academicYear, courses } = formData;

    // 計算學年
    const academicYearCalculated = calculateAcademicYear(
      school.partnershipStartDate,
      school.partnershipEndDate
    );

    // 發送 API 請求
    const response = await fetch(
      "/api/school-service/courses/batch-with-school",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          school: {
            ...school,
            partnershipStartYear: academicYearCalculated,
          },
          contact,
          academicYear,
          courses: courses.map((course) => ({
            ...course,
            academicYear,
          })),
        }),
      }
    );

    // 錯誤處理
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || "建立失敗");
    }

    // 成功後跳轉
    const result = await response.json();
    router.push(`/dashboard/school/courses?schoolId=${result.schoolId}`);
  } catch (error) {
    console.error("Failed to create:", error);
    setErrors({
      submit: error instanceof Error ? error.message : "建立失敗，請稍後再試",
    });
  } finally {
    setIsSubmitting(false);
  }
}, [formData, router]);
```

**流程：**

1. 設定提交狀態（防止重複提交）
2. 計算學年
3. 組裝請求資料
4. 發送 POST 請求
5. 處理錯誤或成功跳轉
6. 重置提交狀態

## 渲染邏輯

### 1. 步驟渲染

```typescript
const renderStep = () => {
  switch (currentStep) {
    case 0:
      return (
        <SchoolFormStep
          schoolData={formData.school}
          contactData={formData.contact}
          onSchoolChange={handleSchoolChange}
          onContactChange={handleContactChange}
          errors={errors}
          schools={schools}
          isLoadingSchools={isLoadingSchools}
          quotationId={quotationId}
        />
      );
    case 1:
      return (
        <CoursesFormStep
          courses={formData.courses}
          onCoursesChange={handleCoursesChange}
          errors={errors}
        />
      );
    case 2:
      return <SummaryFormStep formData={formData} />;
    default:
      return null;
  }
};
```

### 2. 完整 JSX

```typescript
return (
  <>
    {/* 步驟指示器 */}
    <StepIndicator
      steps={STEPS}
      currentStep={currentStep}
      onStepClick={handleStepClick}
    />

    <div className="space-y-6">
      {/* 當前步驟內容 */}
      {renderStep()}

      {/* 提交錯誤訊息 */}
      {errors.submit && (
        <div className="rounded-lg bg-error-50 p-4 text-sm text-error-600 dark:bg-error-900/20 dark:text-error-400">
          {errors.submit}
        </div>
      )}

      {/* 操作按鈕 */}
      <div className="flex items-center justify-between">
        <Button
          variant="outline"
          onClick={currentStep === 0 ? handleCancel : handlePrev}
        >
          {currentStep === 0 ? "取消" : "← 上一步"}
        </Button>

        {currentStep < STEPS.length - 1 ? (
          <Button onClick={handleNext}>下一步 →</Button>
        ) : (
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? "建立中..." : "確認建立課程"}
          </Button>
        )}
      </div>
    </div>
  </>
);
```

## 效能優化

### 1. useCallback 使用

所有事件處理函式都使用 `useCallback` 包裹：

```typescript
const handleSchoolChange = useCallback(..., []);
const handleContactChange = useCallback(..., []);
const handleCoursesChange = useCallback(..., []);
const validateStep1 = useCallback(..., [formData]);
const validateStep2 = useCallback(..., [formData]);
const handleNext = useCallback(..., [currentStep, validateStep1, validateStep2]);
const handlePrev = useCallback(..., []);
const handleStepClick = useCallback(..., []);
const handleSubmit = useCallback(..., [formData, router]);
```

**優點：**

- 避免子元件不必要的重新渲染
- 提升整體效能

### 2. 依賴陣列管理

```typescript
// ✅ 空依賴陣列 - 函式不依賴任何狀態
const handlePrev = useCallback(() => {
  setCurrentStep((prev) => Math.max(prev - 1, 0));
}, []);

// ✅ 包含依賴 - 函式依賴 formData
const validateStep1 = useCallback((): boolean => {
  const { school, contact } = formData;
  // ...
}, [formData]);
```

## 錯誤處理策略

### 1. 即時錯誤清除

```typescript
// 當使用者修正欄位時，立即清除該欄位的錯誤
setErrors((prevErrors) => {
  const newErrors = { ...prevErrors };
  Object.keys(updates).forEach((key) => {
    delete newErrors[key];
  });
  return newErrors;
});
```

### 2. 提交錯誤顯示

```typescript
{
  errors.submit && (
    <div className="rounded-lg bg-error-50 p-4 text-sm text-error-600">
      {errors.submit}
    </div>
  );
}
```

### 3. 欄位錯誤傳遞

```typescript
<SchoolFormStep
  errors={errors} // 傳遞給子元件
  // ...
/>
```

## 使用範例

```typescript
// 在頁面中使用
<NewCourseForm
  schools={schools}
  isLoadingSchools={isLoadingSchools}
  quotationId={quotationId} // 可選
/>
```

## 下一步

閱讀 **[05*表單元件*步驟元件.md](./05_表單元件_步驟元件.md)** 了解各個步驟元件的實作細節。
